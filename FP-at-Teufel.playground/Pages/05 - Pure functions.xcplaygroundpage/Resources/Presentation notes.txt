That is the most obvious FP trait. When you work with a legacy code and want to slowly port it toward a more FP way,
this is definitely the starting point. Grab your functions one by one and extract all the side-effects.

Side-effects are not only mutation in global scope, also reading from global scope is a side-effect. For example, Date()
is an implicit side-effect, which builds something completely different every call. Same for random numbers.

You want to do this before anything else because most of the other topics depend on pure functions.

An exercise is to make a function static or free in the global scope, so you assert they don't read or write from its
object fields. Be extra careful with singletons, Date() or Calendar constructions, or any construction actually, only
other pure constructions and calls should be allowed.

Anything else should be injected from the outside, or even better, the effects should be returned as a value
representation.

Last but not least, functions that take no arguments, or functions that return Void should immediately raise a red flag
in your Functional Programming mind. Pure functions usually take parameters, calculate something and returns the
transformed value. If they return Void, or take no arguments, they are probably running side-effects.

Here we have some examples of functions that have their dependencies injected from outside, and their return type is
very honest about the happy and unhappy paths: Result of either Favorite or Error.

Even if they use repository or Date construction, as long as these calls are pure from the injected dependencies, your
function can also be considered pure.

The async version of it has very similar signature but it returns Promise of either Favorite or Error, very similar
data type to represent a failable and async operation.

We will speak more about these data types later.

The last example is the most powerful. The function won't take any dependencies anymore, and won't run any side-effects.
Instead, the return type of this functions consists in a value that represents both, the effect and the expected return,
which means that this function remains pure and exports the effect to its caller. For keeping the caller also pure, this
also exports the effect to its caller. You keep doing this to move all the effects off your core, toward the boundaries
of your system. In this very naive implementation, `Effect` is a struct generic over 3 parameters: the dependencies it
needs to run the effect, the return type of this effect, and the pure return of the original function, which would be
the return in case the function didn't have to declare the effect.

We will speak more about that soon.
