That is the most obvious FP trait. When you work with a legacy code and want to slowly port it toward a more FP way,
this is definitely the starting point. Grab your functions one by one and extract all the side-effects.

Side-effects are not only mutation in global scope, also reading from global scope is a side-effect. For example, Date()
is an implicit side-effect, which builds something completely different every call. Same for random numbers.

You want to do this before anything else because most of the other topics depend on pure functions.

An exercise is to make a function static or free in the global scope, so you assert they don't read or write from its
object fields. Be extra careful with singletons, Date() or Calendar constructions, or any construction actually, only
other pure constructions and calls should be allowed.

Anything else should be injected from the outside.

Last but not least, functions that take no arguments, or functions that return Void should immediately raise a red flag
in your Functional Programming mind. Pure functions usually take parameters, calculate something and returns the
transformed value. If they return Void, or take no arguments, they are probably running side-effects.

Here we have some examples of functions that have their dependencies injected from outside, and their return type is
very honest about the happy and unhappy paths: Result of either Favorite or Error.

Even if they use repository or Date construction, as long as these calls are pure from the injected dependencies, your
function can also be considered pure.

The async version of it has very similar signature but it returns Promise of either Favorite or Error, very similar
data type to represent a failable and async operation.

We will speak more about there data types later.
