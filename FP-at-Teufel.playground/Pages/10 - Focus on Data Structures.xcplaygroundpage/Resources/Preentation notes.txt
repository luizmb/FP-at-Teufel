We already spoke a lot about Data Structures. They allow us to represent effects or problems as values, by creating
a computational context that can be expressed as a Swift type and composed (purely) in bigger structures, separating
the logic and declaration from the execution and allowing safer programs.

These data structures are small and very specialised containers that are created to solve one, and only one problem.
This is good because:

- by isolating problems per data structure, we have better abstractions
- also allows us to write fewer and better tests, much more relevant and without mocking
- avoids runtime bugs, by having compile-time verifications and pure compositions that are predictable
- with that, also helps preventing race conditions and memory leaks
- and finally, allows to reuse more code

To implement that we:
- abstract ONE specific problem (or effect) per data structure
- make it pure, composable and lazy, providing common and useful operators that we're gonna to see below
- we can also compose multiple data structures by wrapping one inside of another
- and finally execute the effect in isolation and under control

Swift gives us some of these structures, like Optional, Result and Array, focused in solving "nullability", error
handling and collections respectively. These are all very specific effects that could crash an app in the past, but
now are fully verified by the compiler, not in runtime.

By using these Swift generics, we abstract this problem for any kind of wrapped type we store inside alongside with
certain computational context, such as: order and count (for collections), presence or not (for Optional), failure or
not (for Result).

So why not doing the same for asynchronous tasks for example? This is precisely what a Promise does, it holds the
context of a async task, that executes a callback whenever it's done. Or Publishers and Observables, that hold the
context of a pub/sub relationship. And what about Dependency Injection, why not using a data structure to tackle this
problem? This is possible thanks to Reader.

All these types can be wrapped inside of another, the same way you can have
- an optional array
- or an array of optionals
- you can also have a promise of arrays
- or in a more complex example, something that once you inject dependencies, will give you a promise of array

These data-structures offer some useful operators, such as these. It's easy to understand what these operators do with
Arrays. Use your intuition to think what they would mean for the other data structures we mentioned before. This is a
very good homework for you today.
